# Tage 目錄簡介

用於提供分支預測單元的常用實現.

## 設計原理

[參考網頁](../../../../../../doc/分支预测算法（一）：TAGE_SunnyChen的小窝.html)

## TageTable

這個文件設計了所有不同規格的 Tage 的表定義.

## Pred.scala

這個目錄下封裝了多個不同規格 Tage 預測器, 避免其對外提供的方法暴露.(每一次調用方法將會造成面積增長, 要嚴格限制方法的調用.)

我們之所以不再各個 Tage 實現內進行封裝, 是因爲我們不希望將模塊封裝分散到不同的區域.

集中封裝的優勢如下:

1. 用戶可以在一個文件中看到所有預測器的接口, 用戶也僅僅應當訪問這個文件中提供的模塊
2. 可以避免封裝邏輯污染用於實現的文件.
3. 可以減少實現文件的大小.(我們儘量控制在無註釋與空行的情況下, 文件大小在120行左右)

需要注意的是:

各個實現的規格我們並沒有集中定義, 因爲我認爲每一個期望用戶修改的東西, 都應該在一個Config中提供.
而不再Config中的, 應該由我進行規劃, 並保證這個規劃合理

## MiniTage

### 規格參數

### 面積估計

- TageTable有4個，每個表有32條entry，每條entry：
  - pred 3 bit
  - tag 8 bit
  - u 2 bit
  - ➡ 每條13 bit
  - ➡ 每表: 32×13 = 416 bit
- 整個TAGE部分總開銷 ≈ 4×416 = 1664 bit
- base predictor (Bimodal)：
  - 假設是2bit saturating counter (根據你的代碼，應該是)
  - 32 entries × 2bit = 64bit
- GHR：
  - 最大GHR長度=32bit

➡ 合計總bit數量：
`1664 + 64 + 32 = 1760 bit ≈ 220 byte`

✅ 結論：
==對於一個小型CPU核心或者早期prototype，面積非常小，非常合理。Mini-TAGE的設計目標是「小而精」嘛，完美符合這個理念。==
